<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!-- saved from url=(0061)http://www.robot-electronics.co.uk/acatalog/I2C_Tutorial.html -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1"><title>I2C Tutorial</title></head><body onload="PreloadImages(&#39;button_back_highlight.gif&#39;,&#39;button_checkout_highlight.gif&#39;,&#39;button_contact_highlight.gif&#39;,&#39;button_entershop_highlight.gif&#39;,&#39;button_home_highlight.gif&#39;,&#39;button_login_highlight.gif&#39;,&#39;button_search_highlight.gif&#39;,&#39;button_sitemap_highlight.gif&#39;,&#39;button_storetop_highlight.gif&#39;,&#39;button_terms_highlight.gif&#39;,&#39;button_up_highlight.gif&#39;,&#39;button_viewcart_highlight.gif&#39;);"><actinic:basehref value="http://www.robot-electronics.co.uk/acatalog/" forced="0"><meta http-equiv="MSThemeCompatible" content="yes"><meta name="keywords" content="I2C"><meta name="description" content="I2C Tutorial"><link href="./I2C Tutorial_files/actinic.css" rel="stylesheet" type="text/css"><link rel="shortcut icon" href="http://www.robot-electronics.co.uk/acatalog//favicon.ico" type="image/x-icon"><script language="javascript" type="text/javascript" src="./I2C Tutorial_files/actiniccore.js"></script><script language="javascript" type="text/javascript" src="./I2C Tutorial_files/actinicextras.js"></script><actinic:cookiecheck><script language="javascript" type="text/javascript">
<!-- 
saveReferrer();
// -->
</script><table width="100%" cellspacing="0" cellpadding="0" border="0" style="background-image:url(&#39;theme_topbar_background.gif&#39;);"><tbody><tr><td><a href="http://www.robot-electronics.co.uk/index.html"><img src="./I2C Tutorial_files/robot1.png" width="339" height="142" border="0" alt="Online Catalogue" title="Devantech Ltd Online Catalogue" class="logoimage"></a></td><td align="right"><a href="http://www.robot-electronics.co.uk/acatalog/Cameras.html"><img border="0" src="./I2C Tutorial_files/thumb_uCAM.png" alt="uCAM">&nbsp;</a><a href="http://www.robot-electronics.co.uk/acatalog/Ultrasonic_Rangers.html"><img border="0" src="./I2C Tutorial_files/ThumbSrf01.gif" alt="Ultrasonic Rangers"></a>&nbsp;<a href="http://www.robot-electronics.co.uk/acatalog/USB_I2C.html"><img border="0" src="./I2C Tutorial_files/ThumbUSB-I2C.gif" alt="USB to I2C Interfaces"></a>&nbsp;<a href="http://www.robot-electronics.co.uk/acatalog/Ultrasonic_Rangers.html"><img border="0" src="./I2C Tutorial_files/ThumbSrf08.gif" alt="Ultrasonic Rangers"></a>&nbsp;<a href="http://www.robot-electronics.co.uk/acatalog/Drive_Systems.html"><img border="0" src="./I2C Tutorial_files/ThumbRD02a.png" alt="Robot Drive System">&nbsp;</a></td></tr></tbody></table><table width="100%" cellspacing="0" cellpadding="5" border="0" style="background-image:url(&#39;theme_secondbar_background.gif&#39;);" class="secondbar"><tbody><tr><td> &nbsp;</td><td align="right"><a href="http://www.robot-electronics.co.uk/index.html" onmouseover="SwapImage(&#39;br_nav3&#39;,&#39;button_home_highlight.gif&#39;)" onmouseout="RestoreImage()"><img src="./I2C Tutorial_files/button_home.gif" alt="Home" border="0" name="br_nav3"></a>&nbsp;<a href="http://www.robot-electronics.co.uk/acatalog/Contact.html" onmouseover="SwapImage(&#39;br_nav10&#39;,&#39;button_brochure_contact_highlight.gif&#39;)" onmouseout="RestoreImage()"><img src="./I2C Tutorial_files/button_brochure_contact.gif" alt="Contact" border="0" name="br_nav10"></a>&nbsp;<a href="http://www.robot-electronics.co.uk/acatalog/search.html" target="_self" onmouseover="SwapImage(&#39;nav_search&#39;,&#39;button_search_highlight.gif&#39;)" onmouseout="RestoreImage()"><img src="./I2C Tutorial_files/button_search.gif" alt="Search" border="0" name="nav_search"></a>&nbsp;<a href="http://www.robot-electronics.co.uk/cgi-bin/ca000001.pl?ACTION=SHOWCART" target="_self" onmouseover="SwapImage(&#39;nav_cart&#39;,&#39;button_viewcart_highlight.gif&#39;)" onmouseout="RestoreImage()"><img src="./I2C Tutorial_files/button_viewcart.gif" alt="View Cart" border="0" name="nav_cart"></a>&nbsp;<a href="http://www.robot-electronics.co.uk/cgi-bin/os000001.pl?ACTION=Start" target="_self" onmouseover="SwapImage(&#39;nav_checkout&#39;,&#39;button_checkout_highlight.gif&#39;)" onmouseout="RestoreImage()"><img src="./I2C Tutorial_files/button_checkout.gif" alt="Checkout" border="0" name="nav_checkout"></a><actinic:notinb2b><a href="http://www.robot-electronics.co.uk/cgi-bin/ss000001.pl?ACTION=LOGIN" target="_self" onmouseover="SwapImage(&#39;nav_login&#39;,&#39;button_login_highlight.gif&#39;)" onmouseout="RestoreImage()"><img src="./I2C Tutorial_files/button_login.gif" alt="Login" border="0" name="nav_login"></a></actinic:notinb2b> &nbsp;</td></tr></tbody></table><table width="100%" cellspacing="0" cellpadding="5" border="0"><tbody><tr><td valign="top" class="sidebar"><div class="tech_menu_button_title"><p class="tech_text_product_section">Products:</p></div><div class="tech_menu_button_border"><div class="tech_menu_button_product"><a href="http://www.robot-electronics.co.uk/acatalog/BrainStem.html" class="product_section"> BrainStem</a>	</div></div><div class="tech_menu_button_border"><div class="tech_menu_button_product"><a href="http://www.robot-electronics.co.uk/acatalog/Cables.html" class="product_section"> Cables</a>	</div></div><div class="tech_menu_button_border"><div class="tech_menu_button_product"><a href="http://www.robot-electronics.co.uk/acatalog/Cameras.html" class="product_section"> Cameras</a>	</div></div><div class="tech_menu_button_border"><div class="tech_menu_button_product"><a href="http://www.robot-electronics.co.uk/acatalog/Compass.html" class="product_section"> Compass Sensors</a>	</div></div><div class="tech_menu_button_border"><div class="tech_menu_button_product"><a href="http://www.robot-electronics.co.uk/acatalog/Controller_Chips.html" class="product_section"> Controller Chips</a>	</div></div><div class="tech_menu_button_border"><div class="tech_menu_button_product"><a href="http://www.robot-electronics.co.uk/acatalog/DMX512.html" class="product_section"> DMX512</a>	</div></div><div class="tech_menu_button_border"><div class="tech_menu_button_product"><a href="http://www.robot-electronics.co.uk/acatalog/Drive_Systems.html" class="product_section"> Drive Systems</a>	</div></div><div class="tech_menu_button_border"><div class="tech_menu_button_product"><a href="http://www.robot-electronics.co.uk/acatalog/InfraRed_Rangers.html" class="product_section"> InfraRed Rangers</a>	</div></div><div class="tech_menu_button_border"><div class="tech_menu_button_product"><a href="http://www.robot-electronics.co.uk/acatalog/Mains_Adapters.html" class="product_section"> Mains Adapters</a>	</div></div><div class="tech_menu_button_border"><div class="tech_menu_button_product"><a href="http://www.robot-electronics.co.uk/acatalog/Motor_Controllers.html" class="product_section"> Motor Controllers</a>	</div></div><div class="tech_menu_button_border"><div class="tech_menu_button_product"><a href="http://www.robot-electronics.co.uk/acatalog/Processor_Modules.html" class="product_section"> Processor Modules</a>	</div></div><div class="tech_menu_button_border"><div class="tech_menu_button_product"><a href="http://www.robot-electronics.co.uk/acatalog/Relay_Modules.html" class="product_section"> Relay Modules</a>	</div></div><div class="tech_menu_button_border"><div class="tech_menu_button_product"><a href="http://www.robot-electronics.co.uk/acatalog/RF_Modules.html" class="product_section"> RF Modules</a>	</div></div><div class="tech_menu_button_border"><div class="tech_menu_button_product"><a href="http://www.robot-electronics.co.uk/acatalog/Robot_Kits_Bases.html" class="product_section"> Robot Kits &amp; Bases</a>	</div></div><div class="tech_menu_button_border"><div class="tech_menu_button_product"><a href="http://www.robot-electronics.co.uk/acatalog/Serial_Interface.html" class="product_section"> Serial Interface</a>	</div></div><div class="tech_menu_button_border"><div class="tech_menu_button_product"><a href="http://www.robot-electronics.co.uk/acatalog/LCD_Displays.html" class="product_section"> Serial LCD Displays</a>	</div></div><div class="tech_menu_button_border"><div class="tech_menu_button_product"><a href="http://www.robot-electronics.co.uk/acatalog/Servo_s_and_Controllers.html" class="product_section"> Servo's &amp; Controllers</a>	</div></div><div class="tech_menu_button_border"><div class="tech_menu_button_product"><a href="http://www.robot-electronics.co.uk/acatalog/Thermal_Array_Sensor.html" class="product_section"> Thermal Sensors</a>	</div></div><div class="tech_menu_button_border"><div class="tech_menu_button_product"><a href="http://www.robot-electronics.co.uk/acatalog/Ultrasonic_Rangers.html" class="product_section"> Ultrasonic Rangers</a>	</div></div><div class="tech_menu_button_border"><div class="tech_menu_button_product"><a href="http://www.robot-electronics.co.uk/acatalog/USB_I2C.html" class="product_section"> USB to I2C</a>	</div></div><div class="tech_menu_button_border"><div class="tech_menu_button_product"><a href="http://www.robot-electronics.co.uk/acatalog/Best_Sellers.html" class="product_section"> Best Sellers</a>	</div></div><div class="tech_menu_button_border"><div class="tech_menu_button_product"><a href="http://www.robot-electronics.co.uk/acatalog/Obsolete_products.html" class="product_section"> Obsolete Products</a>	</div></div><div class="dev_menu_button_border"><div></div></div><br><div class="tech_menu_button_title"><p class="tech_text_product_section">Information:</p></div><div class="tech_menu_button_border"><div class="tech_menu_button_product"><a href="http://www.robot-electronics.co.uk/acatalog/About_Us.html" class="product_section">About Us</a>	</div></div><div class="tech_menu_button_border"><div class="tech_menu_button_product"><a href="http://www.robot-electronics.co.uk/acatalog/Contact.html" class="product_section">Contact Us</a>	</div></div><div class="tech_menu_button_border"><div class="tech_menu_button_product"><a href="http://www.robot-electronics.co.uk/acatalog/Distributors.html" class="product_section">Distributors</a>	</div></div><div class="tech_menu_button_border"><div class="tech_menu_button_product"><a href="http://www.robot-electronics.co.uk/acatalog/examples.html" class="product_section">Examples</a>	</div></div>	<div class="tech_menu_button_border"><div class="tech_menu_button_product"><a href="http://www.robot-electronics.co.uk/forum/" class="product_section">Forums</a>	</div></div><div class="tech_menu_button_border"><div class="tech_menu_button_product"><a href="http://www.robot-electronics.co.uk/acatalog/WhatsNew.html" class="product_section">Whats New</a>	</div></div><div class="dev_menu_button_border"></div><br></td><td valign="top" class="bulk"><a name="top"></a><actinic:nowserving><actinic:curraccount><actinic:myaccount><actinic:logout_simple><br><div align="center"><p></p></div><div class="content-area"><table border="0" cellpadding="5" cellspacing="0" width="100%"><tbody><tr><td valign="top">  <h1 class="subheading">Using the I2C Bus</h1><p> </p><p align="center"><font size="5">&nbsp;Using the I2C Bus&nbsp;</font></p><p align="left">Judging from my emails, it is quite clear that the I2C bus can be very confusing for the newcomer. I have lots of examples on using the I2C bus on the website, but many of these are using high level controllers and do not show the detail of what is actually happening on the bus. This short article therefore tries to de-mystify the I2C bus, I hope it doesn't have the opposite effect!</p><p align="left"><b>The physical I2C bus</b><br> This is just two wires, called SCL and SDA. SCL is the clock line. It is used to synchronize all data transfers over the I2C bus. SDA is the data line. The SCL &amp; SDA lines are connected to all devices on the I2C bus. There needs to be a third wire which is just the ground or 0 volts. There may also be a 5volt wire is power is being distributed to the devices. Both SCL and SDA lines are "open drain" drivers. What this means is that the chip can drive its output low, but it cannot drive it high. For the line to be able to go high you must provide pull-up resistors to the 5v supply. There should be a resistor from the SCL line to the 5v line and another from the SDA line to the 5v line. You only need one set of pull-up resistors for the whole I2C bus, not for each device, as illustrated below:</p><p align="center"><img border="0" src="./I2C Tutorial_files/i2ca.GIF" width="393" height="141"></p><p align="left">The value of the resistors is not critical. I have seen anything from 1k8 (1800 ohms) to 47k (47000 ohms) used. 1k8, 4k7 and 10k are common values, but anything in this range should work OK. I recommend 1k8 as this gives you the best performance. If the resistors are missing, the SCL and SDA lines will always be low - nearly 0 volts - and the I2C bus will not work. </p><p align="left"><b>Masters and Slaves</b><br> The devices on the I2C bus are either masters or slaves. The master is always the device that drives the SCL clock line. The slaves are the devices that respond to the master. A slave cannot initiate a transfer over the I2C bus, only a master can do that. There can be, and usually are, multiple slaves on the I2C bus, however there is normally only one master. It is possible to have multiple masters, but it is unusual and not covered here. On your robot, the master will be your controller and the slaves will be our modules such as the SRF08 or CMPS03. Slaves will never initiate a transfer. Both master and slave can transfer data over the I2C bus, but that transfer is always controlled by the master.</p><p align="left"><b>The I2C Physical Protocol</b><br> When the master (your controller) wishes to talk to a slave (our CMPS03 for example) it begins by issuing a start sequence on the I2C bus. A start sequence is one of two special sequences defined for the I2C bus, the other being the stop sequence. The start sequence and stop sequence are special in that these are the only places where the SDA (data line) is allowed to change while the SCL (clock line) is high. When data is being transferred, SDA must remain stable and not change whilst SCL is high. The start and stop sequences mark the beginning and end of a transaction with the slave device. </p><p align="center"><img border="0" src="./I2C Tutorial_files/i2cb.GIF" width="486" height="131"> </p><p align="left">Data is transferred in sequences of 8 bits. The bits are placed on the SDA line starting with the MSB (Most Significant Bit). The SCL line is then pulsed high, then low. Remember that the chip cannot really drive the line high, it simply "lets go" of it and the resistor actually pulls it high. For every 8 bits transferred, the device receiving the data sends back an acknowledge bit, so there are actually 9 SCL clock pulses to transfer each 8 bit byte of data. If the receiving device sends back a low ACK bit, then it has received the data and is ready to accept another byte. If it sends back a high then it is indicating it cannot accept any further data and the master should terminate the transfer by sending a stop sequence.&nbsp; </p><p align="center"><img border="0" src="./I2C Tutorial_files/i2cc.GIF" width="390" height="61"></p><p align="left"><b>How fast?</b><br> The standard clock (SCL) speed for I2C up to 100KHz. Philips do define faster speeds: Fast mode, which is up to 400KHz and High Speed mode which is up to 3.4MHz. All of our modules are designed to work at up to 100KHz. We have tested our modules up to 1MHz but this needs a small delay of a few uS between each byte transferred. In practical robots, we have never had any need to use high SCL speeds. Keep SCL at or below 100KHz and then forget about it.</p><p align="left"><b>I2C Device Addressing</b><br> All I2C addresses are either 7 bits or 10 bits. The use of 10 bit addresses is rare and is not covered here. All of our modules and the common chips you will use will have 7 bit addresses. This means that you can have up to 128 devices on the I2C bus, since a 7bit number can be from 0 to 127. When sending out the 7 bit address, we still always send 8 bits. The extra bit is used to inform the slave if the master is&nbsp; writing to it or reading from it. If the bit is zero are master is writing to the slave. If the bit is 1 the master is reading from the slave. The 7 bit address is placed in the upper 7 bits of the byte and the Read/Write (R/W) bit is in the LSB (Least Significant Bit).</p><p align="center"><img border="0" src="./I2C Tutorial_files/i2cd.GIF" width="364" height="57"></p><p align="left">The placement of the 7 bit address in the upper 7 bits of the byte is a source of confusion for the newcomer. It means that to write to address 21, you must actually send out 42 which is 21 moved over by 1 bit. It is probably easier to think of the I2C bus addresses as 8 bit addresses, with even addresses as write only, and the odd addresses as the read address for the same device. To take our CMPS03 for example, this is at address 0xC0 ($C0). You would uses 0xC0 to write to the CMPS03 and 0xC1 to read from it. So the read/write bit just makes it an odd/even address.&nbsp;</p><p align="left"><b>The I2C Software Protocol<br></b>The first thing that will happen is that the master will send out a start sequence. This will alert all the slave devices on the bus that a transaction is starting and they should listen in incase it is for them. Next the master will send out the device address. The slave that matches this address will continue with the transaction, any others will ignore the rest of this transaction and wait for the next. Having addressed the slave device the master must now send out the internal location or register number inside the slave that it wishes to write to or read from. This number is obviously dependant on what the slave actually is and how many internal registers it has. Some very simple devices do not have any, but most do, including all of our modules. Our CMPS03 has 16 locations numbered 0-15. The SRF08 has 36. Having sent the I2C address and the internal register address&nbsp; the master can now send the data byte (or bytes, it doesn't have to be just one). The master can continue to send data bytes to the slave and these will normally be placed in the following registers because the slave will automatically increment the internal register address after each byte. When the master has finished writing all data to the slave, it sends a stop sequence which completes the transaction. So to write to a slave device:&nbsp;<br> 1. Send a start sequence<br> 2. Send the I2C address of the slave with the R/W bit low (even address)<br> 3. Send the internal register number you want to write to<br> 4. Send the data byte<br> 5. [Optionally, send any further data bytes]<br> 6. Send the stop sequence.</p><p align="left">As an example, you have an SRF08 at the factory default address of 0xE0. To start the SRF08 ranging you would write 0x51 to the command register at 0x00 like this:<br> 1. Send a start sequence<br> 2. Send 0xE0 ( I2C address of the SRF08 with the R/W bit low (even address)<br> 3. Send 0x00 (Internal address of the command register)<br> 4. Send 0x51 (The command to start the SRF08 ranging)<br> 5. Send the stop sequence.</p><p align="left"><b>Reading from the Slave</b><br> This is a little more complicated - but not too much more. Before reading data from the slave device, you must tell it which of its internal addresses you want to read. So a read of the slave actually starts off by writing to it. This is the same as when you want to write to it: You send the start sequence, the I2C address of the slave with the R/W bit low (even address) and the internal register number you want to write to. Now you send another start sequence (sometimes called a restart) and the I2C address again - this time with the read bit set. You then read as many data bytes as you wish and terminate the transaction with a stop sequence. So to read the compass bearing as a byte from the CMPS03 module:<br> 1. Send a start sequence<br> 2. Send 0xC0 ( I2C address of the CMPS03 with the R/W bit low (even address)<br> 3. Send 0x01 (Internal address of the bearing register)<br> 4. Send a start sequence again (repeated start)<br> 5. Send 0xC1 ( I2C address of the CMPS03 with the R/W bit high (odd address)<br> 6. Read data byte from CMPS03<br> 7. Send the stop sequence.</p><p align="left">The bit sequence will look like this:</p><p align="center"><img border="0" src="./I2C Tutorial_files/i2c.GIF" width="565" height="182"></p><p align="left"><b>Wait a moment</b><br> That's almost it for simple I2C communications, but there is one more complication. When the master is reading from the slave, its the slave that places the data on the SDA line, but its the master that controls the clock. What if the slave is not ready to send the data! With devices such as EEPROMs this is not a problem, but when the slave device is actually a microprocessor with other things to do, it can be a problem. The microprocessor on the slave device will need to go to an interrupt routine, save its working registers, find out what address the master wants to read from, get the data and place it in its transmission register. This can take many uS to happen, meanwhile the master is blissfully sending out clock pulses on the SCL line that the slave cannot respond to. The I2C protocol provides a solution to this: the slave is allowed to hold the SCL line low! This is called clock stretching. When the slave gets the read command from the master it holds the clock line low. The microprocessor then gets the requested data, places it in the transmission register and releases the clock line allowing the pull-up resistor to finally pull it high. From the masters point of view, it will issue the first clock pulse of the read by making SCL high and then check to see if it really has gone high. If its still low then its the slave that holding it low and the master should wait until it goes high before continuing. Luckily the hardware I2C ports on most microprocessors will handle this automatically.</p><p align="left">Sometimes however, the master I2C is just a collection of subroutines and there are a few implementations out there that completely ignore clock stretching. They work with things like EEPROM's but not with microprocessor slaves that use clock stretching. The result is that erroneous data is read from the slave. Beware!</p><p align="left"><b>Example Master Code</b><br> This example shows how to implement a software I2C master, including clock stretching. It is written in C for the PIC processor, but should be applicable to most processors with minor changes to the I/O pin definitions. It is suitable for controlling all of our I2C based robot modules. Since the SCL and SDA lines are open drain type, we use the tristate control register to control the output, keeping the output register low. The port pins still need to be read though, so they're defined as SCL_IN and SDA_IN. This definition and the initialization is probably all you'll need to change for a different processor.</p><p align="left"><font face="Fixedsys">#define SCL&nbsp;&nbsp;&nbsp;&nbsp; TRISB4	// I2C bus<br> #define SDA&nbsp;&nbsp;&nbsp;&nbsp; TRISB1	//<br> #define SCL_IN&nbsp; RB4&nbsp;&nbsp;&nbsp; //<br> #define SDA_IN&nbsp; RB1&nbsp;&nbsp;&nbsp; //</font></p><p align="left">To initialize the ports set the output resisters to 0 and the tristate registers to 1 which disables the outputs and allows them to be pulled high by the resistors.<br><font face="Fixedsys">SDA = SCL = 1;<br> SCL_IN = SDA_IN = 0;<br><br></font>We use a small delay routine between SDA and SCL changes to give a clear sequence on the I2C bus. This is nothing more than a subroutine call and return.<br><font face="Fixedsys">void i2c_dly(void)<br> {<br> }</font></p><p align="left">The following 4 functions provide the primitive start, stop, read and write sequences. All I2C transactions can be built up from these.<br><font face="Fixedsys">void i2c_start(void)<br> {<br> &nbsp; SDA = 1;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // i2c start bit sequence<br> &nbsp; i2c_dly();<br> &nbsp; SCL = 1;<br> &nbsp; i2c_dly();<br> &nbsp; SDA = 0;<br> &nbsp; i2c_dly();<br> &nbsp; SCL = 0;<br> &nbsp; i2c_dly();<br> }<br></font><br><font face="Fixedsys">void i2c_stop(void)<br> {<br> &nbsp; SDA = 0;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // i2c stop bit sequence<br> &nbsp; i2c_dly();<br> &nbsp; SCL = 1;<br> &nbsp; i2c_dly();<br> &nbsp; SDA = 1;<br> &nbsp; i2c_dly();<br> }</font></p><p align="left"><font face="Fixedsys">unsigned char i2c_rx(char ack)<br> {<br> char x, d=0;<br> &nbsp; SDA = 1;&nbsp;<br> &nbsp; for(x=0; x&lt;8; x++) {<br> &nbsp;&nbsp;&nbsp; d &lt;&lt;= 1;<br> &nbsp;&nbsp;&nbsp; do {<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SCL = 1;<br> &nbsp;&nbsp;&nbsp; }<br> &nbsp; &nbsp; while(SCL_IN==0);&nbsp;&nbsp;&nbsp; // wait for any SCL clock stretching<br> &nbsp;&nbsp;&nbsp; i2c_dly();<br> &nbsp; &nbsp; if(SDA_IN) d |= 1;<br> &nbsp;&nbsp;&nbsp; SCL = 0;<br> &nbsp; }&nbsp;<br> &nbsp; if(ack) SDA = 0;<br> &nbsp; else SDA = 1;<br> &nbsp; SCL = 1;<br> &nbsp; i2c_dly();&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // send (N)ACK bit<br> &nbsp; SCL = 0;<br> &nbsp; SDA = 1;<br> &nbsp; return d;<br> }</font></p><p align="left"><font face="Fixedsys">bit i2c_tx(unsigned char d)<br> {<br> char x;<br> static bit b;<br> &nbsp; for(x=8; x; x--) {<br> &nbsp;&nbsp;&nbsp; if(d&amp;0x80) SDA = 1;<br> &nbsp;&nbsp;&nbsp; else SDA = 0;<br> &nbsp;&nbsp;&nbsp; SCL = 1;<br> &nbsp;&nbsp;&nbsp; d &lt;&lt;= 1;<br> &nbsp;&nbsp;&nbsp; SCL = 0;<br> &nbsp; }<br> &nbsp; SDA = 1;<br> &nbsp; SCL = 1;<br> &nbsp; i2c_dly();<br> &nbsp; b = SDA_IN;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // possible ACK bit<br> &nbsp; SCL = 0;<br> &nbsp; return b;<br> }<br></font><br> The 4 primitive functions above can easily be put together to form complete I2C transactions. Here's and example to start an SRF08 ranging in cm:</p><p align="left"><font face="Fixedsys">i2c_start();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // send start sequence<br> i2c_tx(0xE0);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // SRF08 I2C address with R/W bit clear</font><br><font face="Fixedsys">i2c_tx(0x00);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // SRF08 command register address</font><br><font face="Fixedsys">i2c_tx(0x51);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // command to start ranging in cm</font><br><font face="Fixedsys">i2c_stop();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // send stop sequence</font></p><p align="left">Now after waiting 65mS for the ranging to complete (I've left that to you) the following example shows how to read the light sensor value from register 1 and the range result from registers 2 &amp; 3.</p><p align="left"><font face="Fixedsys">i2c_start();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // send start sequence<br> i2c_tx(0xE0);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // SRF08 I2C address with R/W bit clear</font><br><font face="Fixedsys">i2c_tx(0x01);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // SRF08 light sensor register address</font><br><font face="Fixedsys">i2c_start();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // send a restart sequence<br> i2c_tx(0xE1);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // SRF08 I2C address with R/W bit set</font><br><font face="Fixedsys">lightsensor = i2c_rx(1);&nbsp; // get light sensor and send acknowledge. Internal register address will increment automatically.<br> rangehigh = i2c_rx(1);&nbsp;&nbsp;&nbsp; // get the high byte of the range and send acknowledge.<br> rangelow = i2c_rx(0);&nbsp;&nbsp;&nbsp;&nbsp; // get low byte of the range - note we don't acknowledge the last byte.<br> i2c_stop();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // send stop sequence</font></p><p align="left">Easy isn't it?</p><p align="left">The definitive specs on the I2C bus can be found on the Philips website. It currently <a href="http://www.semiconductors.philips.com/acrobat/literature/9398/39340011.pdf">here</a> but if its moved you'll find it easily be googleing on "i2c bus specification".</p><p align="left">&nbsp; </p><br><p></p></td></tr></tbody></table></div><div class="feefositelogo"></div><div align="center"><p></p></div></actinic:logout_simple></actinic:myaccount></actinic:curraccount></actinic:nowserving></td><td valign="top" class="sidebar"><form name="simplesearch" method="get" action="http://www.robot-electronics.co.uk/cgi-bin/ss000001.pl"><input type="hidden" name="page" value="search"><input type="text" name="SS" size="18" value="Quick Search" onfocus="this.value=&#39;&#39;;" class="quick-search-text">&nbsp;<input type="hidden" name="PR" value="-1"><input type="hidden" name="TB" value="A"><span class="button-wrapper quick-search-button-wrapper"><input class="button quick-search-button" type="submit" name="ACTION" value="Go!"></span></form><br><table width="100" cellspacing="0" cellpadding="5" border="0" align="center"><tbody><tr><td align="center" valign="middle" bgcolor="#000000"><span class="actxxsmall" style="color: #ffffff;"> Items:<script language="javascript" type="text/javascript">
<!--
document.write(getCartItem(3));
// -->
</script>0<br> Value:<script language="javascript" type="text/javascript">
<!--
document.write(getCartItem(1));
// -->
</script>0</span></td></tr></tbody></table><div align="center"><br><strong>See our wide<br>range of sensors</strong><br><br> Ultrasonic<br><a href="http://www.robot-electronics.co.uk/acatalog/Ultrasonic_Rangers.html"><img border="0" src="./I2C Tutorial_files/ThumbSrf08.gif" alt="SRF08 Ultrasonic Ranger"></a><br><br> Compass<br><a href="http://www.robot-electronics.co.uk/acatalog/Compass.html"><img border="0" src="./I2C Tutorial_files/thumbCompass.gif" alt="CMPS03 Magnetic Compass"></a><br><br> Thermal<br><a href="http://www.robot-electronics.co.uk/acatalog/Thermal_Array_Sensor.html"><img border="0" src="./I2C Tutorial_files/thumb-tpa81.gif" alt="TPA81 Thermal Sensor"></a><br><br> Camera<br><a href="http://www.robot-electronics.co.uk/acatalog/Cameras.html"><img border="0" src="./I2C Tutorial_files/thumb_uCAM.png" alt="uCAM"></a><br><br> InfraRed<br><a href="http://www.robot-electronics.co.uk/acatalog/InfraRed_Rangers.html"><img border="0" src="./I2C Tutorial_files/thumbGP2D120.gif" alt="GP2D120 IR Ranger"></a><br><br></div></td></tr></tbody></table></actinic:cookiecheck></actinic:basehref></body></html>